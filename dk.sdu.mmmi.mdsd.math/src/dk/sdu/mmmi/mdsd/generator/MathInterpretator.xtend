/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Model
import dk.sdu.mmmi.mdsd.math.Number
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.VariableReference
import dk.sdu.mmmi.mdsd.math.LocalVariable
import dk.sdu.mmmi.mdsd.math.Variable
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Multiplication
import dk.sdu.mmmi.mdsd.math.Division
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.GlobalVariable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathInterpretator extends AbstractGenerator {

	static Map<String, Integer> variables

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.filter(Model).next
		val result = model.compute

		result.displayPanel
	}

	def static compute(Model model) {
		variables = new HashMap()
		for (variable : model.variables) {
			variables.put(variable.name, variable.expression.computeExp(new HashMap()))
		}
		return variables
	}

	def static dispatch int computeExp(Expression expression, Map<String, Integer> localVariables) {
		switch expression {
			Plus: expression.left.computeExp(localVariables) + expression.right.computeExp(localVariables)
			Minus: expression.left.computeExp(localVariables) - expression.right.computeExp(localVariables)
			Multiplication: expression.left.computeExp(localVariables) * expression.right.computeExp(localVariables)
			Division: expression.left.computeExp(localVariables) / expression.right.computeExp(localVariables)
			Number: expression.value
			Parenthesis: expression.parenthesizedExpression.computeExp(localVariables)
		}
	}

	def dispatch static int computeExp(Variable variable, Map<String, Integer> localVariables) {
		val nestedVariables = new HashMap(localVariables);
		if (variable instanceof LocalVariable) {
			nestedVariables.put(variable.name, variable.local_expression.computeExp(nestedVariables))
		}
		variable.expression.computeExp(nestedVariables)
	}

	def dispatch static int computeExp(VariableReference reference, Map<String, Integer> localVariables) {
		val globalVariable = variables.get(reference.variable.name)
		val localVariable = localVariables.get(reference.variable.name)
		switch reference.variable {
			LocalVariable: localVariable !== null ? localVariable : globalVariable
			GlobalVariable: globalVariable !== null ? globalVariable : reference.variable.computeExp(localVariables)
		}
	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
			resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
		}

		JOptionPane.showMessageDialog(null, resultString, "Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
